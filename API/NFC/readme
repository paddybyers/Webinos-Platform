Abstract

Near Field Communication (NFC) is an international standard (ISO/IEC 18092) that specifies an interface and protocol for simple wireless interconnection of closely coupled devices operating at 13.56 MHz. (http://www.nfc-forum.org/specs/spec_list/). There are three groups of application scenarios for NFC: The first one is to hold a device close to a wireless tag to exchange some digital information or data. The second is to hold two devices close to each other in order to exchange some information or data between them. The third one is to make payments by holding mobile phones close to point of sales terminals instead of swiping smart cards.

Table of Contents

1. Introduction
2. Interfaces
2.1. PendingOperation
2.2. NFCTag
2.3. NFCTagTechnology
2.4. NFCTagTechnologyNdef
2.5. NdefMessage
2.6. NdefRecord
2.7. NfcError
2.8. SuccessCallback
2.9. ErrorCallback
2.10. NdefSuccessCallback
3. Type Definitions
3.1. NFCTagTechnologyArray
3.2. NdefRecordArray
3.3. ByteArray
4. Exceptions
4.1. NfcException
5. Features
6. Full WebIDL
Summary of Methods

Interface	Method
PendingOperation	boolean cancel()
NFCTag	void initNFCTagEvent(DOMString type, boolean bubbles, boolean cancelable, ByteArray tagId, unsigned short technologyType, unsigned short ndefType, unsigned short ndefRecType, DOMString? ndefRecordTextPayload, ByteArray ndefRecordBinaryPayload)
NFCTagTechnology	void connect()
void close()
NFCTagTechnologyNdef	PendingOperation makeReadOnly(SuccessCallback successCallback, ErrorCallback? errorCallback)
NdefMessage readCachedNdefMessage()
PendingOperation readNdefMessage(NdefSuccessCallback successCallback, ErrorCallback? errorCallback)
PendingOperation writeNdefMessage(SuccessCallback successCallback, ErrorCallback? errorCallback, NdefMessage message)
NdefMessage createNdefMessage()
NdefMessage	void addTextNdefRecord(unsigned short type, DOMString payload)
void addBinaryNdefRecord(unsigned short type, ByteArray payload)
NdefRecord	
NfcError	
SuccessCallback	void onsuccess()
ErrorCallback	void onError(NfcError error)
NdefSuccessCallback	void onSuccess(NdefMessage obj)
1. Introduction

Near Field Communication is a kind of radio-frequency identification (RFID) technology that uses short-hold wireless communication to transfer messages between wireless NFC devices and NFC tags. The wireless tags are physically attached onto/ mounted nearby a physical object.

The most common use case is for an NFC device to read the identifier and/or the contents of an NFC tag. Another quite common use case is for an NFC device to write content to an NFC tag, if the NFC tag allows this. The webinos NFC module supports both. There is also a third use case where NFC devices pretend to be contactless smart cards e.g. for payment or ticketing purposes. In general, our objective is with the webinos NFC module is to enable free competition for NFC applications. This means that the goal is to allow any application developers to fully operate on any of these modes.

The purpose of an NFC tag is to provide a small amount of digital data about the physical object that it is associated with - or to help perform a task for the user. One can use either the tag identifier, or some data stored on the tag, to achieve this.

An NFC tag can be viewed as a wireless bar code. It can be read by NFC devices within a range of up to 10 centimetres. The amount of power and resources needed by the NFC device to read and write to an NFC tag is very low.

- NFC APPLICATIONS AND USE CASES

NFC technology is increasingly taking part in every day activities. NFC enables digital data to be associated with real world objects. NFC tags are more advanced than printed bar codes, because one can store a few kilobytes of data on each NFC tag in addition to using its identifier.

NFC is a wireless standard where messages must be exchanged and communicated in a standardised way. This makes NFC very suitable for a wide range of ubiquitous applications. Example applications are within logistics, health care, social media, infotainment, gaming, mobile payments, access to places, system access, inventory control, exchange of business cards, email addresses, web links, images, and so on.

- NFC CORE CONCEPTS

The core concepts of the NFC standard are:

* The NFC devices and NFC tags * The NFC Data Exchange Format

NFC devices are are typically mobile phones or computers with some NFC hardware and a driver installed. Such devices are typically active and try to detect tags, or other devices, nearby. The devices and tags can be provided with identifiers, and these can be both fixed or dynamic depending on the application.

NFC tags can be worn by people or attached to objects in the environment. It enables identification and exchange of a small amount of data in the form of standardised messages that can contain up to several data records each. Each data record contains a header identifying the data followed by the actual data itself. It is completely up to application developers to identify the data, to understand it, and to use the data. Please note that sometimes the term payload is also being used in NFC. Payload in an NFC context simply refers to the raw data or information being stored.

- THE NFC DATA EXCHANGE FORMAT

The NFC Forum has specified the NFC Data Exchange Format (NDEF) to enable interoperability when exchanging data between NFC devices and NFC tags. NDEF is a standard that specifies the NDEF data structure format along with rules on how to compose an NDEF message as a complete collection of NDEF records. An NDEF message is a lightweight, binary message format.

It defines how to package application data as NDEF records. NDEF only specified the data structure format to exchange application specific data in an interoperable way. It does not define any record types in detail. Providing the record header and the actual record data is completely up to the application developer to do.

NDEF is a compact and lightweight binary format. It can contain any data such as web links, business cards, tiny applications, images, and so on. It is up the application developers to define and fill it with literally any data suitable or needed for the application. It is the capabilities of the NFC target that matters. Most NFC tags have generally a few kilobytes of available memory to store the data (payload). NFC devices typically have much more memory available. There are currently four types of NFC tags defined in the standard: type1, type 2, type 3, and type 4. The type vary because of computing capabilities and low level commands, but all NFC targets have to support the exchange of NDEF messages and records.

The advantage of NDEF is that it abstracts away from the specific NFC tags/ targets. An NDEF message consists of a set of NDEF records. Each record must carry data/ payload. The type of data can for instance be web links, MIME media types, or pre-defined NFC data types. An NDEF record consists of two parts: 1) the header part, and 2) the data (payload) part. The compact header part specifies the: i) type of data, ii) the length of the data in terms of octets, and iii) an optional data identifier. The optional data identifier could for instance be used by applications to nest data and records, or for other purposes such as signing. i) and ii) are mandatory to specify in the header of a record. Also, the data (payload) part needs to be provided to the record. The approach to specifying headers allows for compact the identification of standardised data formats across NFC applications. It also allows for the identification of new and custom data formats for any future NFC application.

The NDEF message format can accommodate literally any information or data of known and initially unknown sizes. It allows an arbitrary set of information and data to be grouped together into a single message. It also allows for the compact encapsulation of well-known data such as web links. An NDEF message is not a general message description or document format like MIME media types, HTML, XML and so on. Rather, the purpose is to enable applications to take advantage of such descriptions and formats by encapsulating any of these as NDEF messages and records.

The data (payload) length is an unsigned integer indicating the number of octets in the payload. A compact, short-record layout is provided for very small payloads. The optional payload identifier enables association of multiple data (payloads) and cross-referencing between them. NDEF payloads may include nested NDEF messages or chains of linked chunks of unknown length at the time the data is generated.

- BRIEFLY HOW NFC RADIOS AND MODULES WORK

NFC tags differ from many other RFID tags mainly because of the signal range of the NFC transceivers. Some RFID tags can be read from 100 meters, which is the case when you drive a car through a toll ring with an RFID tag. Such long range wireless tag needs an embedded battery to be able to broadcast the identifier/ data back to the reader. However, because the signal reach of NFC tags and devices is only a few centimetres, the actual NFC tags require no battery. Instead, the active NFC device activates the passive NFC tag with an electro-magnetic field. This field is sufficient to power the NFC chip and drive the data exchange.

- PLANNED OPERATING MODES FOR THE WEBINOS NFC

NFC devices can run in either reader-writer mode, peer-to-peer mode, or card emulation mode. These three modes are based on the ISO/IEC 18092 NFC IP-1 and ISO/IEC 14443 contactless smart card standards. Webinos aim to provide all three modes:

1. NFC reader/writer mode - the NFC device can read and write data to NFC tags. This is the original intention of the NFC technologies. We foresee that most NFC applications will be using this mode in the beginning. One use case is to hold a mobile towards a smart poster to obtain information about a concert.

2. NFC peer to peer mode - two NFC devices exchange data with each other when held close. The devices can connect and share any data/ files through the NFC Logical Link Control Protocol (LLCP). This capability was added to the NFC standard because of the introduction of NFC adapters to mobile phones.

3. NFC card emulation mode - an NFC device appears to another NFC device as a contactless smart card. It makes the NFC device appear as a contactless smart card for payment/ ticketing to other NFC devices. A contactless card an NFC tag with a tiny, secure application embedded on it. Therefore, one needs to emulate cards through the execution of tiny, secure payment applications towards the NFC module.

The implementation priority for the webinos NFC module is in the order if the above three modes: We first will provide the NFC reader/writer mode, then we will deliver the NFC peer to peer mode. Finally, we aim to get the NFC card emulation mode implemented, however, at the moment this latter mode has a lower priority in webinos.

This specification provides a new DOM event ("nfctag") to discover when a nfc tag enters the field of the device.

Code example

 window.addEventListener("nfctag", nfcListener, true);

 function nfcListener(event)
 {
   var techSelected = null;
   var techSupported = event.tag.techList;
   if(techSupported.length > 0) {
     for (var index=0; index < techSupported.length; index++) {
       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
         techSelected = techSupported[index];
       }
     }
   }
   if(techSelected) {
     var ndefMessage = techSelected.readCachedNdefMessage();
     for (var index=0; index < ndefMessage.ndefRecords.length) {
       if(ndefMessage.ndefRecords[index].type = ndefMessage.NDEFRECTYPE_URI)
                        alert("uri found: "+ndefMessage.ndefRecords[index].textPayload);
     }
   }
 }
 
2. Interfaces

2.1. PendingOperation

Definition of pending op.

        [NoInterfaceObject] interface PendingOperation {
                boolean cancel();
        };
Methods

cancel
Cancel the async op.

Signature

boolean cancel();
2.2. NFCTag

NFC tag event.

        interface NFCTag : Event {

                readonly attribute ByteArray tagId;
                
                readonly attribute NFCTagTechnologyArray techList;
                
                void initNFCTagEvent(in DOMString type,
                                     in boolean bubbles,
                                     in boolean cancelable,
                                     in ByteArray tagId,
                                     in unsigned short technologyType,
                                     in unsigned short ndefType,
                                     in unsigned short ndefRecType,
                                     in DOMString? ndefRecordTextPayload,
                                     in optional ByteArray ndefRecordBinaryPayload
                                     );
                                                                 
        };
Attributes

readonly ByteArray tagId
The identifier of the tag.

This attribute is readonly.
readonly NFCTagTechnologyArray techList
The list of technologies supported by the tag.

This attribute is readonly.
Methods

initNFCTagEvent
Method to set initial values of NFCTag event.

Signature

void initNFCTagEvent(in DOMString type, in boolean bubbles, in boolean cancelable, in ByteArray tagId, in unsigned short technologyType, in unsigned short ndefType, in unsigned short ndefRecType, in DOMString? ndefRecordTextPayload, in optional ByteArray ndefRecordBinaryPayload);
The initNFCTagEvent() method must initialize the event in a manner analogous to the initEvent() method in http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/. The method can for example be used with document.createEvent() and EventTarget.dispatchEvent() to simulate a specific event. At the moment it should simulate a read only ndef Tag containing a ndefMessage that includes a single ndefRecord.

Parameters

type
Optional: No.
Nullable: No
Type: DOMString
Description: Event type i.e. 'sensor'
bubbles
Optional: No.
Nullable: No
Type: boolean
Description: True if event bubbles
cancelable
Optional: No.
Nullable: No
Type: boolean
Description: True if event cancelable
tagId
Optional: No.
Nullable: No
Type: ByteArray
Description: id of the tag
technologyType
Optional: No.
Nullable: No
Type: unsigned short
Description: type of technology supported by the tag; at the moment it must be ndef.
ndefType
Optional: No.
Nullable: No
Type: unsigned short
Description: type of ndef supported (see constants defined in NFCTagTechnologyNdef)
ndefRecType
Optional: No.
Nullable: No
Type: unsigned short
Description: type of ndef record (see constants defined in NdefMessage)
ndefRecordTextPayload
Optional: No.
Nullable: Yes
Type: DOMString
Description: textual payload of the ndef record
ndefRecordBinaryPayload
Optional: Yes.
Nullable: No
Type: ByteArray
Description: binary payload of the ndef record
2.3. NFCTagTechnology

NFC technology.

        [NoInterfaceObject] interface NFCTagTechnology {

                const unsigned short TECH_OTHERS = 0;
                
                const unsigned short TECH_NFCA = 1;
                
                const unsigned short TECH_NFCB = 2;
                
                const unsigned short TECH_NFCF = 3;
                
                const unsigned short TECH_NFCV = 4;
                
                const unsigned short TECH_ISODEP = 5;
                
                const unsigned short TECH_NDEF = 6;
                
                readonly attribute unsigned short type;
                
                readonly attribute boolean isConnected;
                
                void connect();

                void close();
                
        };
Constants

unsigned short TECH_OTHERS
Constant identifying a non supported technology.

unsigned short TECH_NFCA
Constant identifying a NfcA technology.

unsigned short TECH_NFCB
Constant identifying a NfcB technology.

unsigned short TECH_NFCF
Constant identifying a NfcF technology.

unsigned short TECH_NFCV
Constant identifying a NfcV technology.

unsigned short TECH_ISODEP
Constant identifying a IsoDep technology.

unsigned short TECH_NDEF
Constant identifying a Ndef technology.

Attributes

readonly unsigned short type
Type of technology.

This attribute is readonly.
readonly boolean isConnected
Attribute indicating if the tag is connected or not.

TODO: check if it is needed.

This attribute is readonly.
Methods

connect
Connects to the tag.

Signature

void connect();
TODO: check if it is needed.

close
Closes connection to the tag.

Signature

void close();
TODO: check if it is needed.

2.4. NFCTagTechnologyNdef

Ndef technology.

        [NoInterfaceObject] interface NFCTagTechnologyNdef : NFCTagTechnology {
        
                const unsigned short NDEFTYPE_OTHERS = 0;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE1 = 1;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE2 = 2;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE3 = 3;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE4 = 4;
                
                const unsigned short NDEFTYPE_MIFARECLASSIC = 5;
                
                readonly attribute unsigned short ndefType;
                
                readonly attribute boolean isWritable;
                
                readonly attribute unsigned long maxNdefMessageSize;
                
                PendingOperation makeReadOnly(in SuccessCallback successCallback, in optional ErrorCallback? errorCallback)
                        raises(NfcException);
                
                NdefMessage readCachedNdefMessage();
                
                PendingOperation readNdefMessage(in NdefSuccessCallback successCallback, in optional ErrorCallback? errorCallback)
                        raises(NfcException);
                
                PendingOperation writeNdefMessage(in SuccessCallback successCallback, in ErrorCallback? errorCallback, NdefMessage message)
                        raises(NfcException);
                
                NdefMessage createNdefMessage();

        };
Code example

 window.addEventListener("nfctag", nfcListener, true);

 function nfcListener(event)
 {
   var techSelected = null;
   var techSupported = event.tag.techList;
   if(techSupported.length > 0) {
     for (var index=0; index < techSupported.length; index++) {
       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
         techSelected = techSupported[index];
       }
     }
   }
   // write to the tag
   if(techSelected) {
     var newMsg = techSelected.createNdefMessage();
     newMsg.addTextNdefRecord(newMsg.NDEFRECTYPE_URI, "http://webinos.org");
     techSelected.writeNdefMessage(wSuccess, wError, newMsg);
   }
 }

 function wSuccess()
 {
   alert("write successfull");
 }

 function wError()
 {
   alert("write error");
 }

 
Constants

unsigned short NDEFTYPE_OTHERS
Constant identifying a non supported Ndef format.

unsigned short NDEFTYPE_NFCFORUMTYPE1
Constant identifying a Nfc forum type 1 Ndef tag.

unsigned short NDEFTYPE_NFCFORUMTYPE2
Constant identifying a Nfc forum type 2 Ndef tag.

unsigned short NDEFTYPE_NFCFORUMTYPE3
Constant identifying a Nfc forum type 3 Ndef tag.

unsigned short NDEFTYPE_NFCFORUMTYPE4
Constant identifying a Nfc forum type 4 Ndef tag.

unsigned short NDEFTYPE_MIFARECLASSIC
Constant identifying a Mifare classic Ndef formatted tag.

Attributes

readonly unsigned short ndefType
Attribute indicating the type of Ndef tag.

This attribute is readonly.
readonly boolean isWritable
Attribute indicating if the tag is writable or not.

This attribute is readonly.
readonly unsigned long maxNdefMessageSize
Attribute indicating the maximum size of Ndef messages.

This attribute is readonly.
Methods

makeReadOnly
This method makes a tag read-only.

Signature

PendingOperation makeReadOnly(in SuccessCallback successCallback, in optional ErrorCallback? errorCallback);
When the operation is fully completed the onsuccess method of the successCallback is called. Otherwise, the errorCallback will be invoked with an appropriate error code amongst the following:

IO_ERR: if the write operation fails.
Parameters

successCallback
Optional: No.
Nullable: No
Type: SuccessCallback
Description: function to be invoked in case of success.
errorCallback
Optional: Yes.
Nullable: Yes
Type: ErrorCallback
Description: function to be invoked in case of failure.
Return value

PendingOperation to cancel the asynchronous call
Exceptions

NfcException:
with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type

readCachedNdefMessage
Retrieves the Ndef message received at discovery time.

Signature

NdefMessage readCachedNdefMessage();
Return value

The Ndef message received at discovery time.
readNdefMessage
This method reads a Ndef message.

Signature

PendingOperation readNdefMessage(in NdefSuccessCallback successCallback, in optional ErrorCallback? errorCallback);
When the operation is fully completed the onsuccess method of the successCallback is called. Otherwise, the errorCallback will be invoked with an appropriate error code amongst the following:

IO_ERR: if the read operation fails.
Parameters

successCallback
Optional: No.
Nullable: No
Type: NdefSuccessCallback
Description: function to be invoked in case of success.
errorCallback
Optional: Yes.
Nullable: Yes
Type: ErrorCallback
Description: function to be invoked in case of failure.
Return value

PendingOperation to cancel the asynchronous call
Exceptions

NfcException:
with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type

writeNdefMessage
Writes a Ndef message to the tag.

Signature

PendingOperation writeNdefMessage(in SuccessCallback successCallback, in ErrorCallback? errorCallback, NdefMessage message);
When the operation is fully completed the onsuccess method of the successCallback is called. Otherwise, the errorCallback will be invoked with an appropriate error code amongst the following:

IO_ERR: if the write operation fails.
Parameters

successCallback
Optional: No.
Nullable: No
Type: SuccessCallback
Description: function to be invoked in case of success.
errorCallback
Optional: No.
Nullable: Yes
Type: ErrorCallback
Description: function to be invoked in case of failure.
message
Optional: No.
Nullable: No
Type: NdefMessage
Description: The message to be written.
Return value

PendingOperation to cancel the asynchronous call
Exceptions

NfcException:
with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type

createNdefMessage
Create a new Ndef message.

Signature

NdefMessage createNdefMessage();
Return value

The new Ndef message; it is empty, that is does not contain ndef records.
2.5. NdefMessage

Ndef message.

        [NoInterfaceObject] interface NdefMessage {
        
                const unsigned short NDEFRECTYPE_UNKNOWN = 0;

                const unsigned short NDEFRECTYPE_URI = 1;

                const unsigned short NDEFRECTYPE_MEDIA = 2;

                const unsigned short NDEFRECTYPE_EMPTY = 3;

                const unsigned short NDEFRECTYPE_RTD = 4;

                const unsigned short NDEFRECTYPE_EXTERNALRTD = 5;

                readonly attribute NdefRecordArray ndefRecords;
                
                void addTextNdefRecord(in unsigned short type, in optional DOMString payload)
                        raises(NfcException);
                
                void addBinaryNdefRecord(in unsigned short type, in ByteArray payload)
                        raises(NfcException);
                
        };
Constants

unsigned short NDEFRECTYPE_UNKNOWN
Constant identifying an unknown Ndef record type.

unsigned short NDEFRECTYPE_URI
Constant identifying a uri Ndef record type.

unsigned short NDEFRECTYPE_MEDIA
Constant identifying a media Ndef record type.

unsigned short NDEFRECTYPE_EMPTY
Constant identifying an empty Ndef record type.

unsigned short NDEFRECTYPE_RTD
Constant identifying a RTD Ndef record type.

unsigned short NDEFRECTYPE_EXTERNALRTD
Constant identifying an external RTD Ndef record type.

Attributes

readonly NdefRecordArray ndefRecords
List of Ndef records.

This attribute is readonly.
Methods

addTextNdefRecord
Adds a text record to the Ndef message.

Signature

void addTextNdefRecord(in unsigned short type, in optional DOMString payload);
TODO add exceptions

Parameters

type
Optional: No.
Nullable: No
Type: unsigned short
Description: The type of the ndef record
payload
Optional: Yes.
Nullable: No
Type: DOMString
Description: The text payload of the record
Exceptions

NfcException:
with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type

addBinaryNdefRecord
Adds a binary record to the Ndef message.

Signature

void addBinaryNdefRecord(in unsigned short type, in ByteArray payload);
TODO add exceptions

Parameters

type
Optional: No.
Nullable: No
Type: unsigned short
Description: The type of the ndef record
payload
Optional: No.
Nullable: No
Type: ByteArray
Description: The binary payload of the record
Exceptions

NfcException:
with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type

2.6. NdefRecord

Ndef record.

        [NoInterfaceObject] interface NdefRecord {
        
                readonly attribute unsigned short type;
                
                readonly attribute DOMString textPayload;
                
                readonly attribute ByteArray binaryPayload;
                
        };
Chunk of records are assembled by the underlying implementation and returned as a single Ndef record.

Attributes

readonly unsigned short type
The type of the record.

This attribute is readonly.
readonly DOMString textPayload
The textual payload of the record.

This attribute is readonly.
readonly ByteArray binaryPayload
The binary payload of the record.

This attribute is readonly.
2.7. NfcError

Interface for reporting Nfc specific errors.

        [NoInterfaceObject] interface NfcError {
            
                readonly attribute unsigned short code;

                readonly attribute DOMString message;

                const unsigned short UNKNOWN_ERR = 0;

                const unsigned short IO_ERR = 1;
                
        };
Constants

unsigned short UNKNOWN_ERR
Unknown error.

unsigned short IO_ERR
I/O error.

Attributes

readonly unsigned short code
Code assigned when an error has occurred in Nfc API processing.

This attribute is readonly.
readonly DOMString message
Human readable message assigned when an error has occurred in Nfc API processing.

This attribute is readonly.
2.8. SuccessCallback

Callback to be invoked in case of success.

        [Callback=FunctionOnly, NoInterfaceObject] interface SuccessCallback {
                void onsuccess();
        };
2.9. ErrorCallback

Callback to be invoked when an error occurs.

        [Callback=FunctionOnly, NoInterfaceObject] interface ErrorCallback {
                void onError(in NfcError error);
        };
2.10. NdefSuccessCallback

Callback to be invoked when reading a Ndef message.

        [Callback=FunctionOnly, NoInterfaceObject] interface NdefSuccessCallback {
                void onSuccess(in NdefMessage obj);
        };
3. Type Definitions

3.1. NFCTagTechnologyArray

Array of NFCTagTechnology.

        typedef NFCTagTechnology[]      NFCTagTechnologyArray;
3.2. NdefRecordArray

Array of NdefRecord.

        typedef NdefRecord[]      NdefRecordArray;
3.3. ByteArray

Array of 8-bit unsigned integer values.

        typedef octet[] ByteArray;
4. Exceptions

4.1. NfcException

        exception NfcException {

                const unsigned short UNKNOWN_ERR = 0;

                const unsigned short INVALID_ARGUMENT_ERR       = 1;

                unsigned short code;

                DOMString message;

        };
Field

unsigned short code
Error code.

DOMString message
Error message.

5. Features

This is the list of URIs used to declare this API's features, for use in the widget config.xml and as identifier for service type in service discovery functionality. For each URI, the list of functions covered is provided.

http://webinos.org/api/nfc
Acccess to all the module. This feature provides access to the whole API.

http://webinos.org/api/nfc.read
Acccess to all the module except write operations.

6. Full WebIDL

module nfc {

        typedef NFCTagTechnology[]      NFCTagTechnologyArray;

        typedef NdefRecord[]      NdefRecordArray;

        typedef octet[] ByteArray;

        [NoInterfaceObject] interface PendingOperation {
                boolean cancel();
        };

        
        interface NFCTag : Event {

                readonly attribute ByteArray tagId;
                
                readonly attribute NFCTagTechnologyArray techList;
                
                void initNFCTagEvent(in DOMString type,
                                     in boolean bubbles,
                                     in boolean cancelable,
                                     in ByteArray tagId,
                                     in unsigned short technologyType,
                                     in unsigned short ndefType,
                                     in unsigned short ndefRecType,
                                     in DOMString? ndefRecordTextPayload,
                                     in optional ByteArray ndefRecordBinaryPayload
                                     );
                                                                 
        };


        [NoInterfaceObject] interface NFCTagTechnology {

                const unsigned short TECH_OTHERS = 0;
                
                const unsigned short TECH_NFCA = 1;
                
                const unsigned short TECH_NFCB = 2;
                
                const unsigned short TECH_NFCF = 3;
                
                const unsigned short TECH_NFCV = 4;
                
                const unsigned short TECH_ISODEP = 5;
                
                const unsigned short TECH_NDEF = 6;
                
                readonly attribute unsigned short type;
                
                readonly attribute boolean isConnected;
                
                void connect();

                void close();
                
        };

        
        [NoInterfaceObject] interface NFCTagTechnologyNdef : NFCTagTechnology {
        
                const unsigned short NDEFTYPE_OTHERS = 0;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE1 = 1;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE2 = 2;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE3 = 3;
                
                const unsigned short NDEFTYPE_NFCFORUMTYPE4 = 4;
                
                const unsigned short NDEFTYPE_MIFARECLASSIC = 5;
                
                readonly attribute unsigned short ndefType;
                
                readonly attribute boolean isWritable;
                
                readonly attribute unsigned long maxNdefMessageSize;
                
                PendingOperation makeReadOnly(in SuccessCallback successCallback, in optional ErrorCallback? errorCallback)
                        raises(NfcException);
                
                NdefMessage readCachedNdefMessage();
                
                PendingOperation readNdefMessage(in NdefSuccessCallback successCallback, in optional ErrorCallback? errorCallback)
                        raises(NfcException);
                
                PendingOperation writeNdefMessage(in SuccessCallback successCallback, in ErrorCallback? errorCallback, NdefMessage message)
                        raises(NfcException);
                
                NdefMessage createNdefMessage();

        };
        

        [NoInterfaceObject] interface NdefMessage {
        
                const unsigned short NDEFRECTYPE_UNKNOWN = 0;

                const unsigned short NDEFRECTYPE_URI = 1;

                const unsigned short NDEFRECTYPE_MEDIA = 2;

                const unsigned short NDEFRECTYPE_EMPTY = 3;

                const unsigned short NDEFRECTYPE_RTD = 4;

                const unsigned short NDEFRECTYPE_EXTERNALRTD = 5;

                readonly attribute NdefRecordArray ndefRecords;
                
                void addTextNdefRecord(in unsigned short type, in optional DOMString payload)
                        raises(NfcException);
                
                void addBinaryNdefRecord(in unsigned short type, in ByteArray payload)
                        raises(NfcException);
                
        };
        
        
        [NoInterfaceObject] interface NdefRecord {
        
                readonly attribute unsigned short type;
                
                readonly attribute DOMString textPayload;
                
                readonly attribute ByteArray binaryPayload;
                
        };
        
        
        [NoInterfaceObject] interface NfcError {
            
                readonly attribute unsigned short code;

                readonly attribute DOMString message;

                const unsigned short UNKNOWN_ERR = 0;

                const unsigned short IO_ERR = 1;
                
        };


        exception NfcException {

                const unsigned short UNKNOWN_ERR = 0;

                const unsigned short INVALID_ARGUMENT_ERR       = 1;

                unsigned short code;

                DOMString message;

        };
        
        
        [Callback=FunctionOnly, NoInterfaceObject] interface SuccessCallback {
                void onsuccess();
        };

        [Callback=FunctionOnly, NoInterfaceObject] interface ErrorCallback {
                void onError(in NfcError error);
        };

        [Callback=FunctionOnly, NoInterfaceObject] interface NdefSuccessCallback {
                void onSuccess(in NdefMessage obj);
        };
        
};
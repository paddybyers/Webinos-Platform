// 
// This module reads an X509 certificate as generated by openssl
// Obvious Gotcha: I rely on the OpenSSL text output, not the PEM file.
// 
// This is generated from the cert.pem file via 
// " openssl x509 -text -in ./cert.pem -pubkey -noout > cert.txt "
//
var x509Reader = exports;

// Add a trim() method to all strings.
String.prototype.trim = function () {
    "use strict";
    return this.replace(/^\s+|\s+$/g, '');
};

//
// Find the lines of the output which contain a public key
// and return them as a string.
//
function findPubKeyLines(lines) {
    "use strict";
    var i = 0;
    var pubKeyStr = "";
    while (i < lines.length && (lines[i].text.indexOf("-----BEGIN PUBLIC KEY-----") !== 0)) {
        i=i+1;
    }
    i=i+1;
    while (i < lines.length && (lines[i].text.indexOf("-----END PUBLIC KEY-----") !== 0)) {
        pubKeyStr = pubKeyStr + lines[i].text;
        i=i+1;
    }
    return pubKeyStr;
}


// Given an object (of our own type) that looks like a signature, 
// turn it into a string containing the signature.
function getSig(obj) {
    "use strict";
    var i;
    var res = "";
    if (obj === null || !obj.hasChildren) {
        return null;
    }
    for (i = 0; i < obj.children.length; i=i+1) {
        res += obj.children[i].text;
    }
    return res;
}

//
// Create a JSON structure out of the possible extensions.
// This is a bit messy, as I can't really predict the output
// of this bit of OpenSSL.
// 
function getExtensions(obj) {
    "use strict";
    var res = {};
    var i;
    if (obj.children.length === 0) {
        return obj.text;
    } else if (obj.children.length === 1) {
        res[obj.text] = getExtensions(obj.children[0]);
        return res;
    } else {
        res[obj.text] = [obj.children.length];
        for (i = 0; i < obj.children.length; i=i+1) {
            res[obj.text][i] = getExtensions(obj.children[i]);
        }
        return res;
    }
}


// Get information about the subject public key, except for the key itself.
// expects the "Subject Public Key Info:" object
function getPubKeyInfo(obj) {
    "use strict";
    var res = {};
    res.algorithm = obj.getChildValue("Public Key Algorithm:").trim();
    res.publicKey = null; //later!
    return res;
}

function getSigAlgorithm(obj) {
    "use strict";
    return obj.text.split(":")[1].trim();
}

// Again, I can't predict the output here, so I'm not returning anything useful
// this is just a placeholder!
function getSubject(obj) {
    "use strict";
    if (obj.hasChildren()) {
        return "??";
    } else {
        return null;
    }
}

//expects O=privacyca.com, CN=Privacy CA Insecure/Unchecked AIK Certificate
function getKeyPairArray(str) {
    "use strict";
    var splitIs;
    var obj = {};
    var i = 0;
    var splitIs2;
    str = str.trim();
    splitIs = str.split(",");
    for (i = 0; i < splitIs.length; i=i+1) {
        splitIs2 = splitIs[i].split("=");
        obj[splitIs2[0]] = splitIs2[1];
    }
    return obj;
}

//Formats a string as a date.  Fortunately, JavaScript does it for us.
function toDate(str) {
    "use strict";
    return new Date(str);
}

//expects a list object with two children
function getValid(obj) {
    "use strict";
    var res = {
        notBefore: toDate(obj.getChildValue("Not Before:").trim()),
        notAfter: toDate(obj.getChildValue("Not After :").trim())
    };
    return res;
}

//In later functions, we take lines of output and turn them into a data
//structure.  Here, we them parse the data structure and turn it into a 
//x509-like certificate.
//inefficiency is paramount :)
function convertToX509(cert) {
 "use strict";
 var x509Prototype = {
     certificate: {
         version: cert.getChildKey("Data").getChildValue("Version:").trim(),
         serialNumber: cert.getChildKey("Data").getChildKey("Serial Number").children[0].text.trim(),
         signature: {},
         issuer: getKeyPairArray(cert.getChildKey("Data").getChildValue("Issuer:")),
         // key value pair
         validity: getValid(cert.getChildKey("Data").getChildKey("Validity")),
         subject: getSubject(cert.getChildKey("Data").getChildKey("Subject")),
         subjectPublicKeyInfo: getPubKeyInfo(cert.getChildKey("Data").getChildKey("Subject Public Key Info")),
         extensions: getExtensions(cert.getChildKey("Data").getChildKey("X509v3 extensions"))
     },
     signatureAlgorithm: getSigAlgorithm(cert.getChildKey("Signature Algorithm")),
     signature: getSig(cert.getChildKey("Signature Algorithm"))
 };
 return x509Prototype;
}



//
//For each line, work out the "parent" line, based on indentation.  
//
function setParent(item, index, resList) {
    "use strict";
    if (item.level === 0 || index === 0 || item.isEmpty()) {
        item.parent = null;
    return;
    }
    while (resList[index - 1].isEmpty()) {
        index = index - 1;
    }
    if (resList[index - 1].level < item.level) {
        item.parent = resList[index - 1];
        item.parent.children[item.parent.children.length] = item;
    } else if (resList[index - 1].level === item.level) {
        item.parent = resList[index - 1].parent;
        item.parent.children[item.parent.children.length] = item;
    } else {
        setParent(item, index - 1, resList);
    }
}

//
// This function takes lines of text and returns a more structured
// data type.  It is inefficient and messy, but gets the job done.
//
// Essentially, it just works out what "level" each bit of the output is 
// and trims all the strings.
// it then calls "setParent" to work out the parent object of the line
// 
function readLine(strs, index, resList) {
    "use strict";
    var i = 0;
    var trimmed;
    var thisObj;
    
    while (strs[index].charAt(i) === " ") { 
        i = i + 1;
    }
    i = i / 4;
    trimmed = strs[index].replace(/^\s+|\s+$/g, '');

    thisObj = {
        text: trimmed,
        level: i,
        pos: index,
        parent: null,
        children: []
    };

    thisObj.isEmpty = function () {
        return (this.text === "");
    };

    thisObj.hasChildren = function () {
        return this.children.length > 0;
    };

    thisObj.getChildKey = function (label) {
        var j = 0;
        for (j = 0; j < this.children.length; j=j+1) {
            if (this.children[j].text.indexOf(label) === 0) {
                return this.children[j];
            }
        }
        return null;
    };
    thisObj.getChildValue = function (label) {
        var j = 0;
        for (j = 0; j < this.children.length; j=j+1) {
            if (this.children[j].text.indexOf(label) === 0) {
                return this.children[j].text.substr(label.length, (this.children[j].text.length - label.length));
            }
        }
        return null;
    };

    setParent(thisObj, index, resList);

    resList[index] = thisObj;
    return resList;
}

//Main entry point: read an X509 output string.
x509Reader.readString = function (str, doneFn) {
    "use strict";
    //first, split by the lines in the file.
    var strs = str.split("\n");
    var i;
    var res;
    var xCert;
    var pubKeyLines;
    
    // now, turn them into a more logical 
    // structure.  
    res = new Array(strs.length);
    for (i = 0; i < strs.length; i=i+1) {
        res = readLine(strs, i, res);
    }

    //now convert into an X509 Structure
    xCert = convertToX509(res[0]);

    //now add the public key lines
    pubKeyLines = findPubKeyLines(res);
    xCert.certificate.subjectPublicKeyInfo.publicKey = pubKeyLines;

    // return the certificate structure.
    doneFn(xCert);
};
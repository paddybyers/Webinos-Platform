/* It is a client to PZH
 * It runs two servers:
 ** TLS server for allowing other PZP's to connect to it
 ** WebSocket Server to allow websocket connection with the browser
 * It is dependent on session common and messaging
 */
(function() {

if (typeof webinos === "undefined") {
	webinos = {};
}

if (typeof exports !== "undefined") {
	//webinos.message = require("../../PZ/PZP/messaging.js");
	webinos.message = require("./messaging.js");
} 
webinos.session = {};
webinos.session.pzh = require('./session_pzh.js');
webinos.session.pzp = {};
webinos.session.common = require('./session_common.js');

var log = console.log,
  tls = require('tls'),
  events = require('events'),
  fs = require('fs'),
  http = require("http"), 
  url = require("url"),
  path = require("path"),
  WebSocketServer = require('websocket').server;


pzp = function() {
	"use strict";
	this.serverPort = 9000;
	// Stores PZH information
	this.serverName = [];
	// Stores own id, this is generated by PZH
	this.sessionId = 0;
	// ServiceSessionId for the connected Apps
	this.serviceSessionId = 0;
	//Configuration details
	this.config = {};
	// List of other connected PZH to PZH. In future, other connected PZH information could also be stored in similar structure
	this.otherPZP = [];
	
	this.connected_pzp = {};
};

//This structure holds socket connection information of the server.
webinos.session.pzp.clientSocket = {};

// It is used by PZP server for holding list of PZP
webinos.session.pzp.connectedClient = [];
// List of connected apps i.e session with browser
webinos.session.pzp.connected_app = {};
// connected pzp
//webinos.session.pzp.connected_pzp = {};

pzp.prototype = new process.EventEmitter();

/* It is responsible for sending message to correct entity. It checks if message is
 * for Apps connected via WebSocket server. It forwards message to the correct 
 * WebSocket client or else message is send to PZH
 * @param message to be sent forward
 */
webinos.session.pzp.sendMessage = function(message, address) {
	var i;
	var self = this;
	if(webinos.session.pzp.connected_app[address]) { 	// it should be for the one of the apps connected.
		log("PZP: Message forwarded to connected app on websocket server ");
		webinos.session.pzp.connected_app[address].sendUTF(JSON.stringify(message));
	} else {
		// This is for communicating with PZH
		log("PZP: Message sent to PZH");	
		webinos.session.pzp.clientSocket.write(JSON.stringify(message));
	}	
};

pzp.prototype.setServiceSessionId = function () {
	this.serviceSessionId++;
	return this.serviceSessionId;
};
/* Similar to PZH with only difference that it generates self signed certificate, 
 * in case if certificates are found it updates the structure.
 */
pzp.prototype.checkFiles = function (filename) {
	"use strict";
	var self, options;
	self = this;
	webinos.session.common.readConfig(filename, self);
	self.on('readConfig',function () {
		webinos.session.common.generateSelfSignedCert(self);
		self.on('generatedCert', function(status) {
			if(status === 'true') {
				options = {
					key: fs.readFileSync(self.config.keyname),
					cert: fs.readFileSync(self.config.certname)
				};
				self.emit('configSet',options);
			} else {
 				options = {
					key: fs.readFileSync(self.config.keyname),
					cert: fs.readFileSync(self.config.certname),
					ca: fs.readFileSync(self.config.mastercertname)
				};
				self.emit('configSet', options);
			}
		});
	});	
};

/* It is responsible for connecting with PZH and handling events.
 * It does JSON parsing of received message
 */
pzp.prototype.connect = function (options, servername, port) {
	"use strict";
	var self, client;
	self = this;
	client = tls.connect(port, servername, options, function(conn) {
		log('PZP: connect status: ' + client.authorized);
		webinos.session.pzp.clientSocket = client;
	});

	client.on('data', function(data) {
		var data1, send, payload = {}, msg = {};
		log('PZP : Received data : ');
		data1 = JSON.parse(data);
		/* If sends the client certificate to get signed certificate from server. 
		 * Payload message format {status: 'clientCert', message: certificate)
		 */
		if (data1.type === 'prop' && data1.payload.status === 'NotAuth') {
			log('PZP: Not Authenticated');
			msg = { 'type': 'prop', 'payload': {'status':'clientCert', 'message':fs.readFileSync(self.config.certname).toString()}};
			webinos.session.pzp.sendMessage(msg);
		} 
		/* It registers with message handler and set methods for message handler. 
		 * It also registers PZH as its client. To enable message to be sent from 
		 * message handler directly. It is responsible for starting server and 
		 * functionality is similar to PZH, except it does not generate certificates 
		 * for connecting PZP. If port is blocked it increments port before connecting.
		 */
		else if (data1.type === 'prop' && data1.payload.status === 'Auth') {
			log('PZP: Authenticated');
			self.serverName = data1.from;
			self.sessionId = data1.to;
			webinos.message.setGet(self.sessionId);
			webinos.message.setSend(webinos.session.pzp.sendMessage);
			//self.connected_pzp[data1.to] = client;
			for (var i = 0 ; i < data1.payload.message.length ; i += 1) {
				self.otherPZP.push(data1.payload.message[i]);
			}

			msg = webinos.message.registerSender(self.sessionId, self.serverName);
			webinos.session.pzp.clientSocket.write(JSON.stringify(msg)); //webinos.session.pzp.sendMessage(msg);
			/*var server = self.startServer();
			server.on('error', function (err) {
				if (err.code == 'EADDRINUSE') {
					log('PZP Server: Address in use');
					self.serverPort = self.serverPort + 1 ;
					server.listen(self.serverPort, servername);
				}
			});

			server.on('listening', function () {
				log('Server PZP: listening as server on port :' + self.serverPort);
			});
				
			server.listen(self.serverPort, servername);*/
			self.emit('startedPZP', 'client started');
		} // It is signed client certificate by PZH
		else if(data1.type === 'prop' && data1.payload.status === 'signedCert') {
			log('PZP: Creating signed client cert' );
			fs.writeFileSync(self.config.certname, data1.payload.clientCert);
			// In case we need to delay things try enabling this log
			//log(fs.readFileSync(self.config.certname));
			log('PZP: Creating server signing cert');
			fs.writeFileSync(self.config.mastercertname, data1.payload.signingCert);
			//log(fs.readFileSync(self.config.mastercertname));
			self.emit('connectPZHAgain','');
		} // This is update message about other connected PZP
		else if(data1.type === 'prop' && data1.payload.status === 'PZPUpdate') {
			log('PZP: Update other PZP details') ;
			for (var i = 0 ; i < data1.payload.message.length ; i += 1) {
				if(self.sessionId !== data1.payload.message[i])
					webinos.session.pzp.otherPZP.push(data1.payload.message[i]);
			}
			log(webinos.session.pzp.otherPZP);
		}
		// Forward message to message handler
		else { 
			log('PZP: Message Forward to Message Handler' + JSON.stringify(data1));
			webinos.message.setGet(self.sessionId);
			webinos.message.setSend(webinos.session.pzp.sendMessage);
			webinos.message.onMessageReceived(JSON.stringify(data1));
		}
	});

	client.on('end', function () {
		log('PZP: Connection teminated');
	});
	
	client.on('error', function (err) {
		log('PZP: Error connecting server' + err.stack);	
	});

	client.on('close', function () {
		log('PZP: Connection closed by PZH');
	});
};

/* starts pzp, creates client, start servers and event listeners
 * @param server name
 * @param port: port on which PZH is running
 */
webinos.session.pzp.startPZP = function(filename, servername, port) {
	"use strict";
	var client = new pzp();
	client.on('configSet',function(status) {
		log('PZP: client connecting');
		client.connect(status, servername, port);		
	});

	client.on('connectPZHAgain',function(status) {
		var options = {	key: fs.readFileSync(self.config.keyname),
					cert: fs.readFileSync(self.config.certname),
					ca: fs.readFileSync(self.config.mastercertname)};
		client.connect(options, servername, port);
	});

	client.checkFiles(filename);
	return client;
};

webinos.session.pzp.startWebSocketServer = function(serverPort, webServerPort) {
	var self = this;
	var cs = http.createServer(function(request, response) {  
		var uri = url.parse(request.url).pathname;  
		var filename = path.join(process.cwd(), uri);  
		path.exists(filename, function(exists) {  
			if(!exists) {  
		        	response.writeHead(404, {"Content-Type": "text/plain"});  
	        		response.write("404 Not Found\n");  
		  		response.end();  
				return;  
			}  
			fs.readFile(filename, "binary", function(err, file) {  
			        if(err) {  
					response.writeHead(500, {"Content-Type": "text/plain"});  
					response.write(err + "\n");  
					response.end();  
					return;  
				}
				response.writeHead(200);  
				response.write(file, "binary");  
				response.end();
    			});
		});  
	})
	
	cs.on('error', function(err) {
		if (err.code == 'EADDRINUSE') {
			var x = parseInt(webServerPort) ;
			x += 1;
			webServerPort = x;
			cs.listen(webServerPort,function(){
				log("PZP Web Server: is listening on port "+webServerPort);
			});
		}
	});

	cs.listen(webServerPort, function(){
		log("PZP Web Server: is listening on port "+webServerPort);
	});

	var httpserver = http.createServer(function(request, response) {
		log("PZP Websocket Server: Received request for " + request.url);
		response.writeHead(404);
		response.end();
	});

	httpserver.on('error' , function(err) {
		if (err.code == 'EADDRINUSE') {
			var x = parseInt(serverPort) 
			x += 1;
			serverPort = x;
			httpserver.listen(serverPort,function(){
				log("PZP Websocket Server: is listening on port "+serverPort);
			});
		}
	});

	httpserver.listen(serverPort, function() {
		log("PZP Websocket Server: Listening on port "+serverPort);
		//self.emit('websocket_started','websocket started');
	});

	webinos.session.pzp.wsServer = new WebSocketServer({
		httpServer: httpserver,
		autoAcceptConnections: true
	});

	webinos.session.pzp.wsServer.on('connect', function(connection) {
		log("PZP Websocket Server: Connection accepted.");
		var pzp, pzh;
		connection.on('message', function(message) {
			log('PZP websocket server received packet');
			self = this;
			var msg = JSON.parse(message.utf8Data);
			log(JSON.stringify(msg));
			// Each message is forwarded back to Message Handler to forward rpc message
			if(msg.type === 'prop' && msg.payload.status === 'registerBrowser') {
				var id = pzp.sessionId+ '/'+pzp.serviceSessionId;
				pzp.serviceSessionId += 1;
				webinos.session.pzp.connected_app[id] = connection;
				var options = {'type': 'prop', 'from': pzp.sessionId, 
					'to': id, 'resp_to': pzp.serverName,
					'payload': {'status': 'registeredBrowser' , 'message': pzp.otherPZP}
				};
	
				connection.sendUTF(JSON.stringify(options));
				// Do we need to send all about connected browser
			} else if(msg.type === 'prop' && msg.payload.status === 'startPZH') {
				fs.writeFile(msg.payload.config.configfile, msg.payload.config.value);
				pzh = webinos.session.pzh.startPZH(msg.payload.config.configfile, msg.payload.servername, msg.payload.serverport);
				// Instantiate and connect to other PZH server
				
				pzh.on('startedPZH', function() {
					log('PZP WebSocket Server: started PZH'); 
					pzh.startHttpsServer(msg.payload.httpserver);
				});
			} else if(msg.type === 'prop' && msg.payload.status === 'startPZP') {
				fs.writeFile(msg.payload.config.configfile, msg.payload.config.value);
				pzp = webinos.session.pzp.startPZP(msg.payload.config.configfile, msg.payload.servername, msg.payload.serverport);
				// Instantiate and connect to other PZH server
				pzp.on('startedPZP', function() {
					log('PZP WebSocket Server: started PZP'); 
				});
			} else if(msg.type === 'prop' && msg.payload.status === 'otherPZH') {
				//fs.writeFile(msg.payload.config.configfile, msg.payload.config.value);
				pzh.connectOtherPZH(msg.payload.servername, msg.payload.serverport);
				// Instantiate and connect to other PZH server
			} else {
				//webinos.message.setGet(self.sessionId);
				//webinos.message.setSend(webinos.session.pzp.sendMessage);
				webinos.message.onMessageReceived(message.utf8Data, message.utf8Data.to);
			}			
		});
		connection.on('close', function(connection) {
       			log("PZP Websocket Server: Peer " + connection.remoteAddress + " disconnected.");
    		});
	});	
};

if (typeof exports !== 'undefined') {
	exports.startPZP = webinos.session.pzp.startPZP;
 	exports.sendMessage = webinos.session.pzp.sendMessage;
	exports.getPZHSessionId = webinos.session.pzp.getPZHSessionId;
	exports.getPZPSessionId = webinos.session.pzp.getPZPSessionId;
	exports.getServiceSessionId = webinos.session.pzp.getServiceSessionId;
}
}());
